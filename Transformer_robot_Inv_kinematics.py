# -*- coding: utf-8 -*-
"""ENPM662_project2_code_shyampi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XfMuMxmm27r3gcsec8usFtIJDnRUijgn

##ENPM662 - Project2 Kinematics code
"""

import numpy as np
from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib import rc
from pprint import pprint

import sympy as sym
from sympy import cos as c
from sympy import sin as s
from sympy import Eq, MatMul, Function, diff
from sympy.matrices import Matrix
from IPython.display import display, Math

import plotly.graph_objs as go
def vis3D(EE_positions):
  X = np.array(EE_positions)
  print(X.shape)
  trace = go.Scatter3d(
    x = X[:,0], y = X[:,1], z = X[:,2],mode = 'markers', marker = dict(
        size = 1,
        color = 'red', # set color to an array/list of desired values
        colorscale = 'reds'
        )
    )

  fig = go.Figure(data = [trace])

  fig.update_layout(
      scene = dict(
              xaxis = dict(nticks=10, range=[-3,3], title = "x axis in metres"),
                      yaxis = dict(nticks=10, range=[-2,2], title = "y axis in metres"),
                      zaxis = dict(nticks=10, range=[-2,2], title = "z axis in metres"),),
      width=1000,
      height=1000,
      margin=dict(r=20, l=10, b=10, t=10))
  fig.show()

"""#Problem 1 : Position Kinematics - Panda"""

theta, d, alpha, a = sym.symbols('theta d alpha a', real = 'True')

theta1, theta2, theta3, theta4, theta5, theta6, theta7 = sym.symbols('theta1 theta2 theta3 theta4 theta5 theta6 theta7', real = 'True')

d1, d3, d5, d7, a3 = sym.symbols('d1 d3 d5 d7 a3', real = 'True')

# thetadot1, thetadot2, thetadot3 = sym.symbols('thetadot1 thetadot2 thetadot3', real = 'True')

T = Matrix([[c(theta), -s(theta)*c(alpha), s(theta)*s(alpha), a*c(theta)],
            [s(theta), c(theta)*c(alpha), -c(theta)*s(alpha), a*s(theta)],
            [0, s(alpha), c(alpha), d],
            [0, 0, 0, 1]])

print("General Transformation Matrix in DH system: \n")
T

"""#Individual Transformation Matrices:"""

TG0 = T.subs([(a, 0), (alpha, 0), (d, 0.242), (theta, 0)])

print("Transformation matrix from frame 0 to G:\n")
TG0

T01 = T.subs([(a, 0), (alpha, sym.pi/2), (d, 0.104), (theta, theta1)])
print("Transformation matrix from frame 1 to 0:\n")
T01

T11_ = T.subs([(a, 0), (alpha, -sym.pi/2), (d, 0), (theta, theta2)])
print("Transformation matrix from frame 3 to 2:\n")
T11_

T1_2 = T.subs([(a, 0), (alpha, -sym.pi/2), (d, 0.457), (theta, 0)])
print("Transformation matrix from frame 4 to 3:\n")
T1_2

T22_ = T.subs([(a, 0), (alpha, sym.pi/2), (d, 0), (theta, theta3)])
print("Transformation matrix from frame 5 to 4:\n")
T22_

T2_3 = T.subs([(a, 0), (alpha, sym.pi/2), (d, 0.94), (theta, 0)])
print("Transformation matrix from frame 6 to 5:\n")
T2_3

T34 = T.subs([(a, 0), (alpha, -sym.pi/2), (d, 0), (theta, theta4)])
print("Transformation matrix from frame 7 to 6:\n")
T34

T45 = T.subs([(a, 0), (alpha, 0), (d, 0.101), (theta, theta5)])
print("Transformation matrix from frame 7 to 6:\n")
T45

T56 = T.subs([(a, 0), (alpha, 0), (d, 0.304+d), (theta, 0)])
print("Transformation matrix from frame 7 to 6:\n")
T56

"""#Final FK Transformation Matrix"""

TG6 = sym.MatMul(TG0,T01,T11_,T1_2,T22_,T2_3,T34,T45,T56, evaluate = True)
print("Final Transformation Matrix before substituting the length values : \n")
TG6

"""#Geometric Validation

Case 1 - All thetas = 0, d = 0
"""

res = TG6.subs([(theta1, 0), (theta2, 0), (theta3, 0), (theta4, 0), (theta5, 0), (d, 0)])

print("Position vector of the end effector with respect to the ground coordinate system : \n")
res[:-1,3]

"""Case 2 - Theta3 = 90 degrees, and theta4 = 270 degrees. All other parameters 0."""

res = TG6.subs([(theta1, 0), (theta2, 0), (theta3, sym.pi/2), (theta4, 3*sym.pi/2), (theta5, 0), (d, 0)])

print("Position vector of the end effector with respect to the first joint's coordinate system : \n")
res[:,3]

"""#Validating Inverse Kinematics"""

TG1 = sym.MatMul(TG0, T01, evaluate = True)

TG2 = sym.MatMul(TG1, T11_,T1_2, evaluate = True)

TG3 = sym.MatMul(TG2, T22_,T2_3, evaluate = True)

TG4 = sym.MatMul(TG3,T34, evaluate = True)

TG5 = sym.MatMul(TG4,T45, evaluate = True)

TG6 = sym.MatMul(TG5,T56, evaluate = True)

"""#Populating the parametric Jacobian matrix"""

J = Matrix( sym.symarray('a', (6,6)) )

J[-3:,0] = TG1[:-1,2]
J[-3:,1] = TG2[:-1,2]
J[-3:,2] = TG3[:-1,2]
J[-3:,3] = TG4[:-1,2]
J[-3:,4] = TG5[:-1,2]
J[-3:,5] = TG6[:-1,2]

J[0:3,0] = TG6[:-1,3].diff(theta1)
J[0:3,1] = TG6[:-1,3].diff(theta2)
J[0:3,2] = TG6[:-1,3].diff(theta3)
J[0:3,3] = TG6[:-1,3].diff(theta4)
J[0:3,4] = TG6[:-1,3].diff(theta5)
J[0:3,5] = TG6[:-1,3].diff(d)

# J = J.subs([(d1, 0.333),(d3, 0.3160),(d5,0.3840),(d7,0.2070),(a3,0.088)])

print("Printing parametric Jacobian:\n")
J

"""#Quantizing the duration of motion in n time steps, and finding velocity of end effector wrt base frame at every time step."""

steps = 200
t = np.linspace(0,20,steps)
t_step = 20/steps

z_init = 0.773
x_init = 1.347

z_dot = 0.01

vel_origin = np.zeros((6,steps))
vel_origin[0,:] = 0
vel_origin[1,:] = 0
vel_origin[2,:] = z_dot

thetas = np.array([0,sym.pi/2,sym.pi/2,sym.pi,0,0])
J_init = J.subs([(theta1, thetas[0]), (theta2, thetas[1]), (theta3, thetas[2]), (theta4, thetas[3]), (theta5, thetas[4]), (d, thetas[5])])
J_init

thetas = np.array([0,sym.pi/2,sym.pi/2,sym.pi,0,0])

j_angles = []
EE_positions = []

EE_base = TG6

for i in range(steps):
  J_step = J.subs([(theta1, thetas[0]), (theta2, thetas[1]), (theta3, thetas[2]), (theta4, thetas[3]), (theta5, thetas[4]), (d, thetas[5])])
  J_step = np.array(J_step).astype(np.float64) + 0.00001
  joint_vel = np.linalg.inv(J_step) @ vel_origin[:,i]

  new_thetas = thetas + t_step*joint_vel

  # print(joint_vel.shape)

  j_angles.append(new_thetas)

  EE_base_temp = EE_base.subs([(theta1, new_thetas[0]), (theta2, new_thetas[1]), (theta3, new_thetas[2]), (theta4, new_thetas[3]), (theta5, new_thetas[4]), (d, new_thetas[5])])

  # print(EE_base_temp)

  EE_base_temp = np.array(EE_base_temp).astype(np.float64)

  EE_position = EE_base_temp[:-1,3]

  EE_positions.append(EE_position)

  thetas = new_thetas

  print("Completed = " + str(i+1) +"/" + str(steps))

j_params = np.array(j_angles).reshape(steps, 6)

fig, axs = plt.subplots(2, 3, figsize = (20,10))
axs[0, 0].plot(t, j_params[:,0]*0)
axs[0, 0].set_title('theta_1')
axs[0, 1].plot(t, j_params[:,1], 'tab:orange')
axs[0, 1].set_title('theta_2')
axs[0, 2].plot(t, j_params[:,2], 'tab:red')
axs[0, 2].set_title('theta_3')
axs[1, 0].plot(t, j_params[:,3], 'tab:green')
axs[1, 0].set_title('theta_4')
axs[1, 1].plot(t, j_params[:,4], 'tab:cyan')
axs[1, 1].set_title('theta_5')
axs[1, 2].plot(t, j_params[:,5], 'tab:pink')
axs[1, 2].set_title('d')

for ax in axs.flat:
    ax.set(xlabel='time in (s)', ylabel='Joint parameter values')

import plotly.graph_objs as go

X = np.array(EE_positions)

trace = go.Scatter3d(
   x = X[:,0]*0, y = X[:,1]*0, z = X[:,2],mode = 'markers', marker = dict(
      size = 1,
      color = 'red', # set color to an array/list of desired values
      colorscale = 'reds'
      )
   )

fig = go.Figure(data = [trace])

fig.update_layout(
    scene = dict(
            xaxis = dict(nticks=10, range=[-0.7,0.7], title = "x axis in metres"),
                     yaxis = dict(nticks=10, range=[-0.45,0.45], title = "y axis in metres"),
                     zaxis = dict(nticks=10, range=[0,1.5], title = "z axis in metres"),),
    width=1000,
    height=1000,
    margin=dict(r=20, l=10, b=10, t=10))
fig.show()